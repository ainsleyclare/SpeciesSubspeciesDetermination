#start of subroutinesdef assignSubsp(subspPairs,spPairs,subSp):    subRoutineResults = [False,[]]    subroutineContinue = True            while subroutineContinue: #iterate to assign subsp to as many as possible in the closest matches group        subroutineContinue = expandSubspList(subspPairs)    subroutineContinue = True        while subroutineContinue: #iterate to assign subsp to as many as out of all strains in the species        subroutineContinue = expandSubspList(spPairs)#check if all strains in close pairs are now assigned subspecies; if not, prepare to send thru the subroutine again                    updatedSubspPairs = []    subspMin = 100    updatedStrainsWcloseMatches = []    checkedStrains = []            for i in range(len(subspPairs)):        thisPair = subspPairs[i]        for j in range(2):            if thisPair[j] not in checkedStrains:                checkedStrains.append(thisPair[j])                checkSubsp = strainInfo[thisPair[j]][1]                if len(checkSubsp) == 0:                    subroutineContinue = True                    updatedSubspPairs.append(thisPair)                    updatedStrainsWcloseMatches.append(thisPair[j])                    if float(thisPair[2]) < subspMin:                            subspMin = float(thisPair[2])    if subroutineContinue:        if subspMin >= 80:            #all remaining strains in the closely matched group are of a single subspecies            subSp = createNewSubsp (updatedSubspPairs[0],subSp)            setSubspecies(updatedStrainsWcloseMatches,subSp[len(subSp-1)])        else:            #two or more additional subspecies exist                                            if len(updatedSubspPairs) > 1: #this should always be the case                                    for i in range(len(updatedSubspPairs)):                    thisPair = updatedSubspPairs[i]                                            if float(thisPair[2]) == subspMin:                        subSp = createNewSubsp (thisPair,subSp)                                                    haveSubsp = getListSubset([thisPair[0],thisPair[1]], "len(strainInfo[origList[i]][1]) > 0")                        whichToExpand = getListSubset([thisPair[0],thisPair[1]], "origList[i] != '"+ haveSubsp[0] + "'")                        setSubspecies(whichToExpand,subSp[len(subSp) - 1])                                         else:                subroutineContinue = False                   subRoutineResults = (subroutineContinue,updatedSubspPairs,subSp)    return subRoutineResultsdef expandSubspList(strainPairsList):    subroutineContinue = False    #expand list    for i in range(len(strainPairsList)):           thisPair = strainPairsList[i]                if float(thisPair[2]) >=85:            haveSubsp = getListSubset([thisPair[0],thisPair[1]], "len(strainInfo[origList[i]][1]) > 0")            if len(haveSubsp) == 1:                k = thisPair.index(haveSubsp[0])                subspToExpand = strainInfo[thisPair[k]][1]                whichToExpand = getListSubset([thisPair[0],thisPair[1]], "origList[i] != '"+ haveSubsp[0] + "'")                setSubspecies(whichToExpand,subspToExpand)                subroutineContinue = True #if a strain have been added to a subspecies, repeat                   return subroutineContinuedef createNewSubsp (strainList,subSp):    #input is a strain pairing where one or both is a new supspecies    newSubsp = "subsp" + str(len(subSp)+1)    haveSubsp = getListSubset([strainList[0],strainList[1]], "len(strainInfo[origList[i]][1]) > 0")    if len(haveSubsp) == 0:        if subSp == ['subsp1']:            strainInfo[strainList[0]][1] ='subsp1'                    strainInfo[strainList[1]][1] = newSubsp #if both might be new subsp, only one gets named at a time (after the first two), in order to prevent creating spurous subsp        subSp.append(newSubsp)    else:                if len(haveSubsp) == 2:            print 'this situation should not occur; please check your data and try again'            raise SystemExit                    else:            #this would only effect addition of a third of more subspecies, and needs to be tested            j = strainList.index(haveSubsp[0])            strainInfo[strainList[j]][1] = newSubsp            subSp.append(newSubsp)    return subSpdef setSubspecies(strainList,strSubspName):    for i in range(len(strainList)):        strainInfo[strainList[i]][1] = strSubspNamedef noSubspecies(sp):    for key, value in strainInfo.iteritems():        if strainInfo[key][0] == sp:            strainInfo[key][1] = 'NA'       def getListOfStrainsInPairlist(pairList, strCriteria):    strainList = []    for i in range(len(pairList)):        criteria = eval(strCriteria)        if criteria:            if pairList[i][0] not in strainList:                strainList.append(pairList[i][0])            if pairList[i][1] not in strainList:                strainList.append(pairList[i][1])    return strainListdef getListSubset(origList, strCriteria):    listSubset = []    for i in range(len(origList)):        criteria = eval(strCriteria)        if criteria:            listSubset.append(origList[i])    return listSubsetdef findSubspecies(sp,spPairs,subSp):        #find all pairings for all strains that have at least one close match (DDH>90)        strainsWcloseMatches = getListOfStrainsInPairlist(spPairs, "float(pairList[i][2]) >= 90")    if len(strainsWcloseMatches) == 0:        #if there are no close matches, subspecies cannot be determined.   Some or all known strains might be representatives of their own subspecies(example: ursingii)        noSubspecies(sp)    else:        #create a subset of matched pairs where both are present in at least one close match.           subspMin = 100        subspPairs = []        for i in range(len(spPairs)):                        if spPairs[i][0] in strainsWcloseMatches and spPairs[i][1] in strainsWcloseMatches:                subspPairs.append(spPairs[i])                if float(spPairs[i][2]) < subspMin:                    subspMin = float(spPairs[i][2])                if subspMin > 80:            #All of the subset are one subsp (ie bruuniana)            setSubspecies(strainsWcloseMatches,subSp[0])        else:            for i in range(len(subspPairs)):                if float(subspPairs[i][2]) == subspMin:                    subSp = createNewSubsp(subspPairs[i],subSp) #no need to add subsp to StrainInfo here as it only occurs if there is just one subsp.                    break            #Assign subspecies; iterate until all strains in the closest matches subset have subspecies asssinged        subroutineContinue = True        while subroutineContinue:                                subRoutineResults = assignSubsp(subspPairs,spPairs,subSp)                subroutineContinue = subRoutineResults[0]                subSp = subRoutineResults[2]                subspPairs = subRoutineResults[1]                   #Now check if any strains remain, and if so, if any of them can be assinged to an existing subspecies                strainsInThisSpecies = getListOfStrainsInPairlist(spPairs,'True')        unassignedStrains = getListSubset(strainsInThisSpecies,"strainInfo[origList[i]][1] == ''")                                                   if len(unassignedStrains) > 0:                        for i in range(len(unassignedStrains)):                                pairlist = getListSubset(spPairs, "origList[i][1] == '" + unassignedStrains[i] + "' or origList[i][0] == '" + unassignedStrains[i] + "'")                dataPerSubsp = {}                for n in range(len(subSp)):                    dataPerSubsp[subSp[n]]=[]                for x in range(len(pairlist)):                    j = pairlist[x].index(unassignedStrains[i])                    if j == 1:                        j = 0                    else:                        j = 1                    otherStrain = pairlist[x][j]                    subspOfOtherStrain = strainInfo[otherStrain][1]                    if len(subspOfOtherStrain) > 0:                        valListPerSubsp = dataPerSubsp[subspOfOtherStrain]                        valListPerSubsp.append(pairlist[x][2])                        dataPerSubsp[subspOfOtherStrain]=valListPerSubsp                                maxValList = 0                for n in range(len(subSp)):                    thisSubsp = subSp[n]                    valListPerSubsp = dataPerSubsp[subSp[n]]                    new_list = [float(n) for n in valListPerSubsp]                                        if len(new_list) > 0:                        aveThisSubsp = sum(new_list)/len(new_list)                        dataPerSubsp[thisSubsp] = aveThisSubsp                        if aveThisSubsp > maxValList:                            maxValList = aveThisSubsp                                   if maxValList >= 80:                    for n in range(len(subSp)):                        if dataPerSubsp[subSp[n]] == maxValList:                            strainInfo[unassignedStrains[i]][1]= subSp[n]                else:                    strainInfo[unassignedStrains[i]][1]= "subsp_" + unassignedStrains[i]                    subSp.append("subsp_" + unassignedStrains[i])                #start of main program#data needs to be formatted a) with headers <StrainNumber1 StrainNumber2 ANIb Formula 2: DDH> and b) sorted by StrainNumber1 then StrainNumber2                    f = open('input.txt', 'r')data = f.readlines()#first read in data and assign species; dataList = []if data[0].split() != ['StrainNumber1', 'StrainNumber2', 'ANIb', 'Formula', '2:', 'DDH']:#first line is headers and is skipped;     print "Headers are wrong"    raise SystemExitfor i in range (1,len(data)):    dataList.append(data[i].split())  #get datadataList.sort()    #populate a dictionary with strains and which species they belong to, keeping a running total of the lowest predicted DDHspeciesData = {'sp1':[[],dataList[0][3]]}numSp = 1strainInfo = {dataList[0][0]:['sp1','']}for i in range(len(dataList)):     if float(dataList[i][2]) > 95:                newMatch = [dataList[i][0],dataList[i][1],dataList[i][3]]                if dataList[i][0] not in strainInfo.keys() or dataList[i][1] not in strainInfo.keys():                        if dataList[i][0] not in strainInfo.keys() and dataList[i][1] not in strainInfo.keys():                numSp = numSp + 1                strainInfo[dataList[i][0]]=['sp' + str(numSp),'']                strainInfo[dataList[i][1]]=['sp' + str(numSp),'']                speciesData['sp' + str(numSp)] = [[],dataList[i][3]]            else:                if dataList[i][0] in strainInfo.keys():                    strainInfo[dataList[i][1]]=[strainInfo[dataList[i][0]][0],'']                else:                    strainInfo[dataList[i][0]]=[strainInfo[dataList[i][1]][0],'']        spData = speciesData[strainInfo[dataList[i][1]][0]]        runningMinDDH = float(spData[1])        if float(dataList[i][3])< float(spData[1]):            runningMinDDH = float(dataList[i][3])                    listOfMatches = spData[0]        listOfMatches.append(newMatch)        speciesData[strainInfo[dataList[i][1]][0]] = [listOfMatches,runningMinDDH]                  #Determine subspecies assignments:       for key, value in speciesData.iteritems() :           if value[1] < 80:            subSp = ['subsp1']            findSubspecies(key, value[0],subSp)                    else:            noSubspecies(key)       #show resultsprintFinalResult = Trueif printFinalResult:    print "Final Strainlist"            for key, value in strainInfo.iteritems() :        print key        print value
